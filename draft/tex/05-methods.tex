\chapter{Описание существующих решений}

\section{Последовательные индексы}

Последовательные индексы деляется на \bfit{кластеризованные (или первичные) и
некластеризованные (или вторичные)???}. В первых записи в проиндексированном
файле храняется \bfit{последовательно упорядоченно (что это значит???)}, во
вторых в порядке отличном от последовательного.

Индексы делятся \bfit(названия подгрупп, так сказать, свои):

\begin{itemize}
    \item по ключу:
        \begin{itemize}
            \item первичные --- ключом поиска является уникальный идентификатор
                записи -- первичный ключ,
            \item вторичные --- включают в себя все остальные индексы;
        \end{itemize}
    \item по физической организации данных:
        \begin{itemize}
            \item кластеризованные ---
            \item некластеризованные ---
        \end{itemize}
    \item по чему-то еще:
        \begin{itemize}
            \item разреженные ---
            \item плотные ---
        \end{itemize}
\end{itemize}

\bfit{рисунки примеры}

Также индексы деляется на разреженные и неразреженные.

\bfit{Неразреженные индексы} содержат ключ поиска и указатель на первую запись с
заданным ключом поиска. При этом в первичных индексах другие записи с заданным
ключом будут лежать сразу после первой записи, так как записи в таких файлах
отсортированны по тому же ключу. Неразреженные вторичные индексы
должны содержать список указателей на каждую запись с заданным ключом поиска.

\bfit{(Сортировать записи в файле??? Не выгодно, только если основная часть
запросов не осуществляется по этому индексy, и сортировка дешевле множества
поисков)}

В \bfit{разреженных индексах} записи содержат только некоторые значения ключа
поиска, а для доступа к элементу отношения ищется запись индекса с наибольшим
меньшим или равным значением ключа поиска, происходит переход по указателю на
первую запись по найденному ключу и далее по указателям в файле происходит поиск
заданной записи. Таким образом, разреженные индексы могут быть построены только
на отсортированных последовательностях записей, иначе хранения только некоторых
ключей поиска будет недостаточно, так как будет неизвестно, после записи, с
каким ключом будет лежать необходимый элемент отношения.

Рисунки как в книжке

Поиск с помощью неразреженных индексов быстрее, так как указатель в записи
индекса сразу приводит к необходимым записям. Однако разреженные индексы требуют
меньше дополнительной памяти и сокращают время поддержания структуры индекса в
актуальном состоянии при вставке или удалении.

Решение, о том какой тип индексов использовать, принимается разработчиком для
каждого приложения отдельно. \bfit{(Хорошо --- разреженный индекс по блокам памяти,
так как основные затраты по времени приходятся на загрузку данных из вторичной
памяти в оперативную, но хорошо --- абстрактное понятие; + как решить ситуация,
когда данные одного ключа поиска лежат в разных блоках ;)}.

\subsection{$B$-tree индексы}

B-tree индексы можно рассматривать как модель сопоставления ключа позиции
искомой записи в отсортированном массиве.

\red{Лучший} выбор для запросов диапазонов в силу упорядоченности данных.

Такие индексы как бы предсказывают положение записи с \bfit{минимаксной
(верно?)} ошибкой (min err = 0, max err = page\_size). Поэтому можем заминить
B-деревья на линейную модель также с минимаксной ошибкой (возможно/скорее всего
другой).

Так для предсказания можно представлять Range Index Models как модели функции
распределения:

\begin{equation}
    \text{position} = F(key) \cdot N,
\end{equation}


где $F(key)$ --- функция распределения, дающая оценку вероятности обнаружения
ключа, меньшего или равного ключу поиска, то есть $P(X < key)$;

~~~~$N$ --- количество ключей.

\textit{График позиции от ключа}

Можно построить индексы на основе рекурсивной модели, в которой строится
иерархия моделей из n уровней (этапов). Каждая модель на вход получает ключ, на
основе которого выбирает модель на следующем уровне. Модели последнего этапа
предсказывают положение записи.

Картиночка иерархии моделей.

Можно использовать различные модели: например, на верхнем использовать нейнонные
сети, а на нижних простые линейные регрессионные модели или даже простые
B-деревья.

Алгоритм страница 8.

Для индексирвония строк используют токенизацию --- представление строки в виде
чисел (NLP).


\subsection{$B^+$-tree индексы}

\subsection{$R$-tree индексы (не из книги, часто упоминаются в статьях)}

\subsection{LSM-tree индексы (оптимизация)}

\subsection{Буферные деревья}

\bfit{Нужно написать, что есть куча других деревьев, описаны самые часто
используемые ;)}

\section{Хеш-индексы}

Хеш-индексы можно рассматривать как модель сопоставления ключа позиции
искомой записи в неупорядоченном массиве.

\red{Лучшее} --- поиск по простому ключу.

Фукнция распределения вероятностей распределения ключей (CDF of the key
detribution) один из возможных способов обучения хеш-индексов. CDF
масштабируется на размер хеш-таблицы $M$ и для поиска положения записи
аналогично случаю с B-деревьями используется формула:

\begin{equation}
    h(K) = F(K) \cdot M,
\end{equation}

где $K$ --- ключ.

\section{Индексы на основе битовых карт}

Данные индексы можно рассматривать как модель проверки существования записи в
массиве данных.

\bfit{Фильтр Блума?} (как раз алгоритм используемый для проверки) очевидно
\red{эффективен} для проверки существования записи.

Фильтр Блума использует массив бит размером $m$ и $k$ хеш-функций, каждая из
которых сопоставляет ключ с одну из $m$ позиций. Для добавления элемента в
множество существующих значений ключ подается на вход каждой хеш-функции,
возвращающих позицию бита, который должен быть установлен в 1. Для проверки
принадлежности ключа множеству, ключ также подается на вход $k$ хеш-функций.
Если какой-либо бит, соответствующий одной из возращенных позиций, равен нулю,
то ключ не входит во множество.Из этого следует, что данный алгоритм гарантирует
отсутсвие ложноотрицательных результатов.

\textit{Может со 100\%-ной вероятностью сказать, что элемент отсутсвует в
наборе, но то, что элемент присутсвует в наборе, со 100\%-ной вероятностью он
сказать не может (возможны ложноположитеьные результаты)}

В случае индексов существования необходимо обучить функцию таким образом, чтобы
среди возвращенных значений для множества ключей были коллизии, аналогично для
множества неключей, но при этом не было коллизий возращенных значений для ключей
и неключей. (это надо переписать, непонятно написано: возвращенные значения для
ключей должны попадать в одни значения, для неключей -- в другие, но множества
возвращенных значений для ключей и неключей не должны совпадать)

В отличие от оригинального фильтра Блума, где FNR = 0, FPR = const, где const
выбрано априори, при обучении достигается заданное значение FPR при FNR = 0 на
реальных запросах.



\section{Индексирование пространственных и временных данных}
