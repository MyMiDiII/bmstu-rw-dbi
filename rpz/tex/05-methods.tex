\chapter{Описание существующих методов построения индексов\label{methods}}

Как было сказано выше индексы обеспечивают быстрый поиск записей, поэтому в их
основе лежат структуры, предназначенные для решения этой задачи. По данным
структурам индексы подразделяются на
\begin{itemize}
    \item индексы на основе деревьев поиска,
    \item индексы на основе хеш-таблиц,
    \item индексы на основе битовых карт.
\end{itemize}

\section{Индексы на основе деревьев поиска}

\textit{Дерево поиска} --- иерархическая структура, используемая для поиска
записей, которая осуществляет работу с отсортированными значениями ключей и в
которой каждый переход на более низкий уровень иерархии уменьшает интервал
поиска. При использовании деревьев поиска для построения индексов необходимо
учитывать, что требуется обеспечить как ускорение поиска данных, так и
уменьшение затрат на обновление индекса при вставках и удалениях. По этим
причинам при решении задачи поиска в базах данных используют сбалансированные
сильноветвящиеся деревья~\cite{arki}.

В данном случае \textit{сбалансированными деревьями} называют такие деревья, что
длины любых двух путей от корня до листьев одинаковы~\cite{encycl}.
\textit{Сильноветвящимися} же являются деревья, каждый узел которых ссылается на
большое число потомков~\cite{squares}.  Эти условия обеспечивают минимальную
высоту дерева для быстрого поиска и свободное пространство в узла для внесения
изменений в базу данных без необходимости изменения индекса при каждой операции.

Наиболее используемыми деревьями поиска, имеющими описанные свойства, являются
B-деревья и их разновидность --- B$^+$-деревья~\cite{arki}.

\subsection{B-деревья}

\textit{B-дерево} --- это сбалансированная, сильноветвящаяся древовидная,
работающая с отсортированными значениями структура данных, операции вставки и
удаления в которой не изменяют ее свойств~\cite{loshad}. Все свойства данной
структуры поддерживаются путем сохранения в узлах положений для включения новых
элементов~\cite{baw}. Это осуществляется за счет свойств узлов, которые
определяются порядком B-дерева~$m$.

\textit{B-деревом порядка~$m$}~\cite{baw, arki} называется дерево поиска, такое
что:

\begin{itemize}
    \item каждый узел имеет формат, описывающийся формулой~\eqref{eq:01}:
        \begin{equation}\label{eq:01}
            (P_1, (K_1, Pr_1), P_2, (K_2, Pr_2), \dots, (K_{q-1}, Pr_{q-1}),
            P_q),
        \end{equation}

        где $q \leqslant m$,

        $P_i$ --- указатель на $i$-ого потомка в случае внутреннего узла или
        пустой указатель в случае внешнего~(листа),

        $K_i$ --- ключи поиска,

        $Pr_i$ --- указатель на запись, соответствующую ключу поиска $K_i$;

    \item для каждого узла выполняется $K_1 < K_2 < \dots < K_q$;

    \item для каждого ключа поиска $X$ потомка, лежащего по указателю $P_i$
        выполняются условия, описывающиеся формулой~\eqref{eq:02}:

        \begin{equation}\label{eq:02}
            \begin{aligned}
                K_{i-1} < X < K_i, & \text{ если } 1 < i < q,\\
                X < K_i, & \text{ если } i = 1,\\
                K_{i-1} < X, & \text{ если } i = q;
            \end{aligned}
        \end{equation}

    \item каждый узел содержит не более $m - 1$~ключей поиска или, что то же
        самое, имеет не более $m$~потомков;

    \item каждый узел за исключением корня содержит не менее $\lceil m / 2
        \rceil - 1$~ключей поиска, или, что то же самое, имеет не менее~$\lceil
        m / 2 \rceil$ потомков;

    \item корень может содержать минимум один ключ, либо, что то же самое, иметь
        минимум два потомка;

    \item каждый узел за исключением листьев, содержащий $q-1$~ключей, имеет
        $q$~потомков;

    \item все листья находятся на одном и том же уровне.
\end{itemize}

В случае с индексами к каждому ключу поиска во всех узлах добавляется указатель
на запись, соответствующую этому ключу. Другими словами, каждый узел содержит
набор указателей, ссылающихся на дочерние узлы, и набор пар, каждая из которых
состоит из ключа поиска и указателя, ссылающегося на данные. При этом записи с
данными хранятся отдельно и частью B-дерева не являются~\cite{arki}.

Пример B-дерева представлен на рисунке~\ref{img:node}.
~\\

\imgs{node}{h!}{1}{Пример B-дерева}

Построение B-дерева~\cite{flatfish} начинается с создания корневого узла. В него
происходит вставка до полного заполнения, то есть до того момента, пока все
$q-1$ позиций не будут заняты. При вставке $q$-ого значения создается новый
корень, в который переносится только медиана значений, старый корень разделяется
на два узла, между которыми равномерно распределяются оставшиеся
значения~(рисунок~\ref{img:rootInsert}). Два созданных узла становятся потомками
нового корня.

\imgw{rootInsert}{h!}{17cm}{Пример вставки в B-дерево при заполненном корне}

Когда некорневой узел заполнен и в него должен быть вставлен новый ключ, этот
узел разделяется на два узла на том же уровне, а средняя запись перемещается в
родительский узел вместе с двумя указателями на новые разделенные узлы. Если
родительский узел заполнен, он также разделяется. Разделение может
распространяться вплоть до корневого узла, при разделении которого создается
новый уровень~(рисунок~\ref{img:leafInsert}). Фактически дерево строится
последовательным выполнением операций вставки.

\imgw{leafInsert}{h!}{17cm}{Пример вставки в B-дерево при последовательном
заполнении узлов разных уровней}
 
Поиск в B-дереве начинается с корня. Если искомое ключевое значение $X$ найдено
в узле, то есть какой либо ключ $K_i$ в нем равен $X$, то доступ к нужной записи
осуществляется по соответвующему указателю $Pr_i$. Если значение не найдено,
происходит переход к поддереву по указателю $P_i$, соответвующему наименьшему
значению $i$, такому, что $X < K_i$. Если $X$ больше $K_i$ для любого значения
$i \in \overline{1, q - 1}$, то переход осуществляется по указателю $P_q$.
Далее действия повторяются для того поддерева, к которому произошел переход, до
тех пор, пока не будет найдено нужное значение или не будет достигнут конец
листового узла, что означает отсутствие искомого ключа~\cite{arki}.

Удаление значений основано на той же идее. Нужное значение удаляется из узла, в
котором оно находится, и если количество значений в узле становится меньше
половины максимально возможного количества значений, то узел объединяется с
соседними узлами, что также может распространяться вплоть до
корня.~\bfit{расписать бы по-хорошему + чем не угодили b-деревья} 

%\bfit{недостатки? из арок}
%
%Очень сложно сделать точные прогнозы относительно требуемого количества
%обращений к блокам при поиске по B-дереву. Существует множество возможных
%конфигураций, каждый узел может содержать от k до 2k значений ключа (за
%исключением корня), и дерево может принимать различные формы в зависимости от
%разделения узлов и слияний.  Например, на рисунке 12.27 для поиска значения
%ключа 24 требуется три произвольных доступа к блокам в первом B-дереве, один
%доступ к блокам во втором B-дереве и два доступа к блокам в третьем дереве. Для
%поиска ключевого значения 17 требуется три, два, и один блок доступа,
%соответственно. Высота дерева и, следовательно , максимальное количество
%обращений к случайным блокам для поиска определенного значения ключа в дереве
%будут уменьшаться по мере увеличения порядка дерева.
%
%Обратите также внимание, что сбалансированность B-дерева является важным
%свойством в этом контексте. При несбалансированном дереве путь от корня к
%конечному узлу не был бы одинаковым для всех конечных узлов, что привело бы к
%еще большему разбросу во времени поиска.


\subsection{B$^+$-деревья}

Структура B$^+$-дерева аналогична структуре B-дерева за исключением двух
моментов.  Во-первых, внутренние узлы не содержат указателей на записи, в них
хранятся только значения ключей, то есть внутренние узлы имеют формат,
описывающийся формулой~\eqref{eq:03}:

\begin{equation}\label{eq:03}
    (P_1, K_1, P_2, K_2, \dots, K_{q-1}, P_q),
\end{equation}

где $q \leqslant m$,

$P_i$ --- указатель на $i$-ого потомка,

$K_i$ --- ключи поиска.

Указатели на данные содержатся только в листьях. При этом каждый ключ,
содержащийся во внутренних узлах, встречается в каком-либо листе, то есть
условие, представленное формулой~\eqref{eq:02}, для B$^+$-деревьев
модернизируется в формулу~\eqref{eq:04}:

\begin{equation}\label{eq:04}
    \begin{aligned}
        K_{i-1} < X \leqslant K_i, & \text{ если } 1 < i < q,\\
        X \leqslant K_i, & \text{ если } i = 1,\\
        K_{i-1} < X, & \text{ если } i = q.
    \end{aligned}
\end{equation}

Все остальные свойства B-дерева порядка $m$ верны и для B$^+$-дерева.

Во-вторых, каждый листовой узел содержит только пары (ключ, указатель на данные)
и не содержит указателей на потомков, так как при любых операциях листы не может
стать внутренним узлом, а также структура внешнего узла отличается от структуры
внутренних. При этом в конец каждого листа добавляется указатель на следующий
лист.

Пример B$^+$-дерева приведен на рисунке~\ref{img:bplustree}.

\imgs{bplustree}{h!}{1}{Пример B$^+$-дерева}

В силу того, что листы имеют структуру, они могут иметь порядок отличный от
порядка внутренних узлов, что позволяет уменьшить высоту дерева, а следовательно
и количество блоков памяти, к которым необходимо обратиться, что позволяет
сократить время поиска. Наличие же во внешних узлах всех ключей и указателей на
соседние листы, предоставляет новый способ обхода дерева --- последовательно по
листам, что даёт возможность быстрее обрабатывать запросы на поиск в диапазоне.
Операции вставки и удаления элементов в B$^+$-дерево аналогичны соответствующим
операциям на B-дереве, \bfit{за исключением}. Из-за большей скорости поиска по
сравнению с B-деревьями и аналогичных операций B$^+$-деревья частно назвают
просто B-деревьями, подменяя исходный термин.

\subsection{Обученные индексы}

Индексы на основе B-деревьев можно рассматривать как модель сопоставления ключа
с позицией искомой записи в отсортированном массиве, или в терминах машинного
обучения, как дерево принятия решения. Такие индексы сопоставляют ключ положению
записи с минимальной ошибкой, равной нулю, и максимальной ошибкой, равной
размеру страницы, гарантируя, что искомое значение принадлежит указанному
диапазону~(рисунок~\ref{img:btree}). 

\imgs{btree}{h!}{1}{B-деревья}

Поэтому B-дерево может быть заменено на какую-либо модель машинного обучения,
включая нейронные сети, при условии, что эта модель будет также гарантировать
принадлежность записи некоторому диапазону~(рисунок~\ref{img:learnedbtree}).

\imgs{learnedbtree}{h!}{1}{Обученный индекс}

\bfit{При этом будет учитываться распределение данных (путем cdf)}
Так для предсказания можно представлять Range Index Models как модели функции
распределения~(рисунок~\ref{img:cdf}):

\begin{equation}
    \text{position} = F(key) \cdot N,
\end{equation}

где $F(key)$ --- функция распределения, дающая оценку вероятности обнаружения
ключа, меньшего или равного ключу поиска, то есть $P(X < key)$;

~~~~$N$ --- количество ключей.

\imgs{cdf}{h!}{1}{Индекс как функция распределения}

Можно построить индексы на основе рекурсивной
модели~(рисунок~\ref{img:rmi}), в которой строится иерархия моделей из n
уровней. Каждая модель на вход получает ключ, на основе которого выбирает модель
на следующем уровне. Модели последнего этапа предсказывают положение записи.

\imgs{rmi}{h!}{1}{Рекурсивная модель индекса}

Можно использовать различные модели: например, на верхнем использовать нейронные
сети, а на нижних простые линейные регрессионные модели или даже простые
B-деревья.

\section{Индексы на основе хеш-таблиц}

Альтернативным способом построения индексов является хеширование. Идея этого
подхода заключается в применении к значению ключа поиска некоторой функции
свертки, называющейся \textit{хеш-функцией}, по определенному алгоритму вырабатывающей
значение, определяющее адрес в таблице, содержащей ключи и записи или указатели
на записи, называющейся \textit{хеш-таблицей}~\cite{osip}. Следует учитывать,
что разные ключи могут быть преобразованы хеш-функцией в одно и то же значение.
Такая ситуация называется \textit{коллизией} и должна быть каким-либо способом
разрешена.

К хеш-функциям предъявляется ряд требований~\cite{baw, marvel}:
\begin{itemize}
    \item значения, получаемые в результате применения хеш-функции к ключу
        должны принадлежать диапазону значений, определяющему действительные
        адреса в хеш-таблице;
    \item значения хеш-функции должны быть равномерно распределены для
        уменьшения числа коллизий;
    \item хеш-функция должна при одном и том же входном значении выдавать одно
        и то же выходное.
\end{itemize}

\subsection{Хеш-индексы}

Для построения индекса на основе хеш-таблиц выбирается единица хранения,
именуемая
\mbox{\textit{бакетом}~(англ.~bucket~---~\mbox{корзина}})~\cite{marvel} или
\mbox{\textit{хеш-разделом}~\cite{amur}}, которая может содержать одну или
несколько индексных записей, при этом их количество фиксировано~\cite{ship}.

Первоначально создается некоторое количество бакетов, которые и составляют
хеш-таблицу. Хеш-функция, получая на вход ключ, отображает его в номер
хеш-раздела в таблице. В случае, если раздел не заполнен, запись, состоящая из
ключа и указателя на данные, помещается в него. Если же в разделе нет места для
вставки новой записи, то есть возникает коллизия и необходимо найти новое место
для вставки~\cite{marvel}. Процесс поиска такого места называется разрашением
коллизии и может выполняться~\cite{baw}:

\begin{itemize}
    \item \textit{методом открытой адресации}, при котором ищется первая свободная
        позиция в последующих незаполненнных хеш-разделах;
    \item \textit{методом цепочек переполнения}, заключающийся в создании хеш-разделы
        переполнения, к каждому из которых, включая раздел в хеш-таблице,
        добавляется указатель на следующих раздел, что создает связный список,
        относящийся к одному значению хеш-функции;
    \item \textit{методом двойного хеширования}, при получении коллизии в
        результате применении первой хеш-функции используется вторая и метод
        открытой адресации при повторной коллизии, возможно влючение и третьей
        хеш-функции.
\end{itemize}

Операции поиска, вставки и удаления в хеш-индексе зависят от используемого
метода разрешения коллизий. Простейшим в этом плане и рассматривающимся далее
при описании обученных хеш-индексов явлется метод переполнения цепочек, в
котором поиск, вставка и удаление являются операциями над связным
списком~\cite{baw}.

Пример хеш-индекса с разрешением коллизий по методу цепочек переполнения,
приведен на рисунке~\ref{img:buckethash}.

\imgs{buckethash}{h!}{1}{Пример структуры хеш-индекса с разрешением коллизий
методом цепочек переполнения}

Хеш-индексы обеспечивают временную сложность в среднем и лучшем случае ---
$O(1)$, в худшем случае --- $O(n)$~\cite{squares}.

Существование коллизий подчеркивает потенциальную проблему использования
хеш-индесов~\cite{squares}. Так при заполнении хеш-таблицы более чем на~$70\%$
возникающие коллизии увеличивают время поиска в~1.5-2.5~раза при любом из
методов разрешения коллизий~\cite{baw}.

Для предотвращения появления коллизий используют также методы динамического
хеширования, при котором при вставках и удалениях размер исходной хеш-таблицы
увеличивается или уменьшается соответственно. К таким методам относят:
\begin{itemize}
    \item расширяемое хеширование~(\textit{extendible hashing})~\cite{encycl},
        представляющее значение хеш-функции как битовую строку и использующее из
        нее количество бит, необходимое для однозначной идентификации текущего
        количества записей в таблице;
    \item и линейное хеширование~(\textit{linear hashing})~\cite{encycl}, при
        необходимости изменяющее размер таблицы на один хеш-раздел.
\end{itemize}

Однако они также имеют недостатки. При расширяемом хешировании из-за увеличения
числа учитывающихся разрядов в битовой строке размер таблицы каждый раз
увеличивается в два раза, что может не оправдаться в случае, если дальнейших
вставок в таблицу не произойдет. При этом линейное хеширование не исключает
создание разделов переполнения~\cite{encycl}.

\subsection{Обученные хеш-индексы}

Традиционные хеш-индексы, описанные выше, могут быть рассмотрены как модели
сопоставления ключа позиции искомой записи в неупорядоченном массиве, а
следовательно могут быть заменены моделями машинного обучения.  Обученные
хеш-индексы~\cite{main} основаны на предположении, что модели машинного
обучения, учитывающие распределение ключей, могут без увеличения размеров
хеш-таблицы уменьшить количество коллизий. Для этого функция распределения
ключей~$F$ масшитабируется на размер хеш-таблицы~$M$, а в качестве хеш-функции
используется выражение, описывающееся формулой~\eqref{eq:05}:

\begin{equation}\label{eq:05}
    h(K) = F(K) \cdot M,
\end{equation}

где $K$ --- ключ.

Таким образом, обученный хеш-индекс учитывает эмпирическое распределение ключей,
что позволяет уменьшать колличество коллизий по сравнению с обычными
хеш-таблицами~(рисунок~\ref{img:hashlearnedhash}).

\imgw{hashlearnedhash}{h!}{17cm}{Сравнение традиционных и обученных
хеш-индексов}

Так как, обученный индекс уменьшает, но не предотвращает появление коллизий, его
временные сложности совпадают со сложностями традиционного хеш-индекса.

\section{Индексы на основе битовых карт}

\subsection{Фильтр Блума}

Данные индексы можно рассматривать как модель проверки существования записи в
массиве данных.

Фильтр Блума --- алгоритм используемый для проверки существования записи.

Фильтр Блума использует массив бит размером $m$ и $k$ хеш-функций, каждая из
которых сопоставляет ключ с одну из $m$ позиций. Для добавления элемента в
множество существующих значений ключ подается на вход каждой хеш-функции,
возвращающих позицию бита, который должен быть установлен в единицу. Для
проверки принадлежности ключа множеству, ключ также подается на вход $k$
хеш-функций.  Если какой-либо бит, соответствующий одной из возращенных позиций,
равен нулю, то ключ не входит во множество. Из этого следует, что данный
алгоритм гарантирует отсутсвие ложноотрицательных результатов.

\imgs{bloom}{h!}{0.3}{Bitmap-индексы}

%\textit{Может со 100\%-ной вероятностью сказать, что элемент отсутсвует в
%наборе, но то, что элемент присутсвует в наборе, со 100\%-ной вероятностью он
%сказать не может (возможны ложноположительные результаты)}

\subsection{Обученные индексы}

В случае индексов существования необходимо обучить функцию таким образом, чтобы
среди возвращенных значений для множества ключей были коллизии, аналогично для
множества неключей, но при этом не было коллизий возращенных значений для ключей
и неключей. 

\imgs{bloom}{h!}{0.3}{Обученные bitmap-индексы}

В отличие от оригинального фильтра Блума, где $FNR = 0$, $FPR = const$, где
const выбрано априори, при обучении достигается заданное значение $FPR$ при $FNR
= 0$ на реальных запросах.
