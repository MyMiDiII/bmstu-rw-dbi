\chapter{Описание существующих решений}

\section{Последовательные индексы}

Последовательные индексы деляется на \bfit{кластеризованные (или первичные) и
некластеризованные (или вторичные)???}. В первых записи в проиндексированном
файле храняется \bfit{последовательно упорядоченно (что это значит???)}, во
вторых в порядке отличном от последовательного.

\bfit{рисунки примеры}

Также индексы деляется на разреженные и неразреженные.

\bfit{Неразреженные индексы} содержат ключ поиска и указатель на первую запись с
заданным ключом поиска. При этом в первичных индексах другие записи с заданным
ключом будут лежать сразу после первой записи, так как записи в таких файлах
отсортированны по тому же ключу. Неразреженные вторичные индексы
должны содержать список указателей на каждую запись с заданным ключом поиска.

\bfit{(Сортировать записи в файле??? Не выгодно, только если основная часть
запросов не осуществляется по этому индексy, и сортировка дешевле множества
поисков)}

В \bfit{разреженных индексах} записи содержат только некоторые значения ключа
поиска, а для доступа к элементу отношения ищется запись индекса с наибольшим
меньшим или равным значением ключа поиска, происходит переход по указателю на
первую запись по найденному ключу и далее по указателям в файле происходит поиск
заданной записи. Таким образом, разреженные индексы могут быть построены только
на отсортированных последовательностях записей, иначе хранения только некоторых
ключей поиска будет недостаточно, так как будет неизвестно, после записи, с
каким ключом будет лежать необходимый элемент отношения.

Рисунки как в книжке

Поиск с помощью неразреженных индексов быстрее, так как указатель в записи
индекса сразу приводит к необходимым записям. Однако разреженные индексы требуют
меньше дополнительной памяти и сокращают время поддержания структуры индекса в
актуальном состоянии при вставке или удалении.

Решение, о том какой тип индексов использовать, принимается разработчиком для
каждого приложения отдельно. \bfit{(Хорошо --- разреженный индекс по блокам памяти,
так как основные затраты по времени приходятся на загрузку данных из вторичной
памяти в оперативную, но хорошо --- абстрактное понятие; + как решить ситуация,
когда данные одного ключа поиска лежат в разных блоках ;)}.

\subsection{$B^+$-tree индексы}

\subsection{$B$-tree индексы}

\subsection{LSM-tree индексы (оптимизация)}

\subsection{Буферные деревья}

\section{Хеш-индексы}

\section{Индексы на основе битовых карт}

\section{Индексирование разреженных (пространственных) и временных данных}
