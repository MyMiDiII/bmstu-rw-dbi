\chapter{Описание существующих решений}

\section{Последовательные индексы}

Последовательные индексы деляется на \bfit{кластеризованные (или первичные) и
некластеризованные (или вторичные)???}. В первых записи в проиндексированном
файле храняется \bfit{последовательно упорядоченно (что это значит???)}, во
вторых в порядке отличном от последовательного.

\bfit{рисунки примеры}

Также индексы деляется на разреженные и неразреженные.

\bfit{Неразреженные индексы} содержат ключ поиска и указатель на первую запись с
заданным ключом поиска. При этом в первичных индексах другие записи с заданным
ключом будут лежать сразу после первой записи, так как записи в таких файлах
отсортированны по тому же ключу. Неразреженные вторичные индексы
должны содержать список указателей на каждую запись с заданным ключом поиска.

\bfit{(Сортировать записи в файле??? Не выгодно, только если основная часть
запросов не осуществляется по этому индексy, и сортировка дешевле множества
поисков)}

В \bfit{разреженных индексах} записи содержат только некоторые значения ключа
поиска, а для доступа к элементу отношения ищется запись индекса с наибольшим
меньшим или равным значением ключа поиска, происходит переход по указателю на
первую запись по найденному ключу и далее по указателям в файле происходит поиск
заданной записи. Таким образом, разреженные индексы могут быть построены только
на отсортированных последовательностях записей, иначе хранения только некоторых
ключей поиска будет недостаточно, так как будет неизвестно, после записи, с
каким ключом будет лежать необходимый элемент отношения.

Рисунки как в книжке

Поиск с помощью неразреженных индексов быстрее, так как указатель в записи
индекса сразу приводит к необходимым записям. Однако разреженные индексы требуют
меньше дополнительной памяти и сокращают время поддержания структуры индекса в
актуальном состоянии при вставке или удалении.

Решение, о том какой тип индексов использовать, принимается разработчиком для
каждого приложения отдельно. \bfit{(Хорошо --- разреженный индекс по блокам памяти,
так как основные затраты по времени приходятся на загрузку данных из вторичной
памяти в оперативную, но хорошо --- абстрактное понятие; + как решить ситуация,
когда данные одного ключа поиска лежат в разных блоках ;)}.

\subsection{$B$-tree индексы}

B-tree индексы можно рассматривать как модель сопоставления ключа позиции
искомой записи в отсортированном массиве.

\red{Лучший} выбор для запросов диапазонов в силу упорядоченности данных.

Такие индексы как бы предсказывают положение записи с \bfit{минимаксной
(верно?)} ошибкой (min err = 0, max err = page\_size). Поэтому можем заминить
B-деревья на линейную модель также с минимаксной ошибкой (возможно/скорее всего
другой).

Так для предсказания можно представлять Range Index Models как модели функции
распределения:

\begin{equation}
    \text{position} = F(key) \cdot N,
\end{equation}


где $F(key)$ --- функция распределения, дающая оценку вероятности обнаружения
ключа, меньшего или равного ключу поиска, то есть $P(X < key)$;

~~~~$N$ --- количество ключей.

\textit{График позиции от ключа}

Можно построить индексы на основе рекурсивной модели, в которой строится
иерархия моделей из n уровней (этапов). Каждая модель на вход получает ключ, на
основе которого выбирает модель на следующем уровне. Модели последнего этапа
предсказывают положение записи.

Картиночка иерархии моделей.

Можно использовать различные модели: например, на верхнем использовать нейнонные
сети, а на нижних простые линейные регрессионные модели или даже простые
B-деревья.

Алгоритм страница 8.

Для индексирвония строк используют токенизацию --- представление строки в виде
чисел (NLP).


\subsection{$B^+$-tree индексы}

\subsection{$R$-tree индексы (не из книги, часто упоминаются в статьях)}

\subsection{LSM-tree индексы (оптимизация)}

\subsection{Буферные деревья}

\bfit{Нужно написать, что есть куча других деревьев, описаны самые часто
используемые ;)}

\section{Хеш-индексы}

Хеш-индексы можно рассматривать как модель сопоставления ключа позиции
искомой записи в неупорядоченном массиве.

\red{Лучшее} --- поиск по простому ключу.

\section{Индексы на основе битовых карт}

Данные индексы можно рассматривать как модель проверки существования записи в
массиве данных.

\bfit{Фильтр Блума?} (как раз алгоритм используемый для проверки) очевидно
\red{эффективен} для проверки существования записи.

\textit{Может со 100\%-ной вероятностью сказать, что элемент отсутсвует в
наборе, но то, что элемент присутсвует в наборе, со 100\%-ной вероятностью он
сказать не может (возможны ложноположитеьные результаты)}

\section{Индексирование пространственных и временных данных}
