\chapter{Описание существующих методов построения индексов\label{methods}}

Как было сказано выше индексы обеспечивают быстрый поиск записей, поэтому в их
основе лежат структуры, предназначенные для решения этой задачи. По данным
структурам индексы подразделяются на
\begin{itemize}
    \item индексы на основе деревьев поиска,
    \item индексы на основе хеш-таблиц,
    \item индексы на основе битовых карт.
\end{itemize}

\section{Индексы на основе деревьев поиска}

Дерево поиска --- иерархическая структура, используемая для поска записей,
которая осуществляет работу с отсортированными значениями ключей и в которой
каждый переход на более низкий уровень иерархии уменьшает интервал поиска. При
использовании деревьев поиска для построения индексов необходимо учитывать, что
требуется обеспечить как ускорение поиска данных, так и уменьшение затрат на
обновление индекса при вставках и удалениях. По этим причинам при решении задачи
поиска в базах данных используют сбалансированные сильноветвящиеся
деревья~\cite{arki}.

В данном случае сбалансированными деревьями назвают такие деревья, что длины
любых двух путей от корня до листьев одинаковы~\cite{encycl}. Сильноветвящимися
же являются деревья, каждый узел которых ссылается на большое число
потомков~\cite{squares}.  Эти условия обеспечивают минимальную высоту дерева для
быстрого поиска и свободное пространство в узла для внесения изменений в базу
данных без необходимости изменения индекса при каждой операции.

Наиболее используемыми деревьями поиска, имеющими описанные свойства, являются
B-деревья и их разновидность --- $B^+$-деревья~\cite{arki}.

\subsection{B-деревья}

B-дерево --- это сбалансированная, сильноветвящаяся древовидная, работающая с
отсортированными значениями структура данных, операции вставки и удаления в
которой не изменяют ее свойств~\cite{loshad}. Сбалансированность поддерживается
путем построения структуры таким образом, что в узлах остаются положения для
включения новых элементов~\cite{baw}. Это осществляется за счет
свойств узлов, которые определяются порядком B-дерева~$m$.

\textit{B-деревом порядка~$m$}~\cite{baw, arki} называется дерево поиска,
такое что:

\begin{itemize}
    \item каждый узел имеет формат, описывающийся формулой~\ref{eq:01}:
        \begin{equation}\label{eq:01}
            (P_1, (K_1, Pr_1), P_2, (K_2, Pr_2), \dots, (K_{q-1}, K_{q-1}),
            P_q),
        \end{equation}

        где $q \leqslant m$,

        $P_i$ --- указатель на $i$-ого потомка в случае внутреннего узла или
        пустой указатель в случае внешнего~(листа),

        $K_i$ --- ключи поиска,

        $Pr_i$ --- указатель на запись, соответствующую ключу поиска $K_i$;

    \item для каждого узла выполняется $K_1 < K_2 < \dots < K_q$;

    \item для каждого ключа поиска $X$ потомка, лежащего по указателю $P_i$
        выполняются условия, описывающиеся формулой~\ref{eq:02}:

        \begin{equation}\label{eq:02}
            \begin{aligned}
                K_{i-1} < X < K_i, & \text{ если } 1 < i < q,\\
                X < K_i, & \text{ если } i = 1,\\
                K_{i-1} < X, & \text{ если } i = q;
            \end{aligned}
        \end{equation}

    \item каждый узел содержит не более $m - 1$~ключей поиска или, что то же
        самое, имеет не более $m$~потомков;

    \item каждый узел за исключением корня содержит не менее $\lceil m / 2
        \rceil - 1$~ключей поиска, или, что то же самое, имеет не менее~$\lceil
        m / 2 \rceil$ потомков;

    \item корень может содержать минимум один ключ, либо, что то же самое, иметь
        минимум два потомка;

    \item каждый узел за исключением листьев, содержащий $q-1$~ключей, имеет
        $q$~потомков;

    \item все листья находятся на одном и том же уровне.
\end{itemize}

В случае с индексами к каждому ключу поиска во всех узлах добавляется указатель
на запись, соответствующую этому ключу. Другими словами, каждый узел содержит
набор указателей, ссылающихся на дочерние узлы, и набор пар, каждая из которых
состоит из ключа поиска и указателя, ссылающегося на данные. При этом записи с
данными хранятся отдельно и частью B-дерева не являются~\cite{arki}.

Пример B-дерева представлен на рисунке~\ref{img:node}.

\imgs{node}{h!}{1}{Пример B-дерева}

%\bfit{недостатки? из арок}
%
%Очень сложно сделать точные прогнозы относительно требуемого количества
%обращений к блокам при поиске по B-дереву. Существует множество возможных
%конфигураций, каждый узел может содержать от k до 2k значений ключа (за
%исключением корня), и дерево может принимать различные формы в зависимости от
%разделения узлов и слияний.  Например, на рисунке 12.27 для поиска значения
%ключа 24 требуется три произвольных доступа к блокам в первом B-дереве, один
%доступ к блокам во втором B-дереве и два доступа к блокам в третьем дереве. Для
%поиска ключевого значения 17 требуется три, два, и один блок доступа,
%соответственно. Высота дерева и, следовательно , максимальное количество
%обращений к случайным блокам для поиска определенного значения ключа в дереве
%будут уменьшаться по мере увеличения порядка дерева.
%
%Обратите также внимание, что сбалансированность B-дерева является важным
%свойством в этом контексте. При несбалансированном дереве путь от корня к
%конечному узлу не был бы одинаковым для всех конечных узлов, что привело бы к
%еще большему разбросу во времени поиска.

%Как они выглядят?
%
%Как происходит поиск в B-деревьях
%
%Как они строятся?
%Как изменяются при вставке?
%
%Построение B-дерева происходит с помощью вставок.
%
%Как изменяются при удалении?
%
%Для чего подходят?

\subsection{\boldmath$B^+$-деревья}

Отличие от B-деревьев

Картинка

\subsection{Обученные индексы}

B-tree индексы можно рассматривать как модель сопоставления ключа позиции
искомой записи в отсортированном массиве~(рисунок~\ref{img:btree}).

\imgs{btree}{h!}{1}{B-деревья}

Такие индексы как бы предсказывают положение записи с минимаксной ошибкой
($min\_err = 0$, $max\_err = page\_size$). Поэтому можем заминить B-деревья на
линейную модель также с минимаксной ошибкой~(рисунок~\ref{img:learnedbtree}).

\imgs{learnedbtree}{h!}{1}{Обученный индекс}

Так для предсказания можно представлять Range Index Models как модели функции
распределения~(рисунок~\ref{img:cdf}):

\begin{equation}
    \text{position} = F(key) \cdot N,
\end{equation}

где $F(key)$ --- функция распределения, дающая оценку вероятности обнаружения
ключа, меньшего или равного ключу поиска, то есть $P(X < key)$;

~~~~$N$ --- количество ключей.

\imgs{cdf}{h!}{1}{Индекс как функция распределения}

Можно построить индексы на основе рекурсивной
модели~(рисунок~\ref{img:rmi}), в которой строится иерархия моделей из n
уровней. Каждая модель на вход получает ключ, на основе которого выбирает модель
на следующем уровне. Модели последнего этапа предсказывают положение записи.

\imgs{rmi}{h!}{1}{Рекурсивная модель индекса}

Можно использовать различные модели: например, на верхнем использовать нейронные
сети, а на нижних простые линейные регрессионные модели или даже простые
B-деревья.

\section{Индексы на основе хеш-таблиц}

\subsection{Хеш-индексы}


\subsection{Обученные хеш-индексы}

Хеш-индексы можно рассматривать как модель сопоставления ключа позиции
искомой записи в неупорядоченном массиве.

\imgs{hash}{h!}{1}{Хеш-индекс}

Функция распределения вероятностей распределения ключей  один из возможных
способов обучения хеш-индексов. Функция распределения масштабируется на размер
хеш-таблицы $M$ и для поиска положения записи аналогично случаю с B-деревьями
используется формула:

\begin{equation}
    h(K) = F(K) \cdot M,
\end{equation}

где $K$ --- ключ.

\imgs{learnedhash}{h!}{1}{Обученный хеш-индекс}

\section{Индексы на основе битовых карт}

\subsection{Фильтр Блума}


\subsection{Обученные индексы}

Данные индексы можно рассматривать как модель проверки существования записи в
массиве данных.

Фильтр Блума --- алгоритм используемый для проверки существования записи.

Фильтр Блума использует массив бит размером $m$ и $k$ хеш-функций, каждая из
которых сопоставляет ключ с одну из $m$ позиций. Для добавления элемента в
множество существующих значений ключ подается на вход каждой хеш-функции,
возвращающих позицию бита, который должен быть установлен в единицу. Для проверки
принадлежности ключа множеству, ключ также подается на вход $k$ хеш-функций.
Если какой-либо бит, соответствующий одной из возращенных позиций, равен нулю,
то ключ не входит во множество. Из этого следует, что данный алгоритм гарантирует
отсутсвие ложноотрицательных результатов.

\imgs{bloom}{h!}{0.3}{Bitmap-индексы}

%\textit{Может со 100\%-ной вероятностью сказать, что элемент отсутсвует в
%наборе, но то, что элемент присутсвует в наборе, со 100\%-ной вероятностью он
%сказать не может (возможны ложноположительные результаты)}

В случае индексов существования необходимо обучить функцию таким образом, чтобы
среди возвращенных значений для множества ключей были коллизии, аналогично для
множества неключей, но при этом не было коллизий возращенных значений для ключей
и неключей. 

В отличие от оригинального фильтра Блума, где $FNR = 0$, $FPR = const$, где
const выбрано априори, при обучении достигается заданное значение $FPR$ при $FNR
= 0$ на реальных запросах.
