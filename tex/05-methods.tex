\chapter{Описание существующих методов построения индексов\label{methods}}

Как было сказано выше индексы обеспечивают быстрый поиск записей, поэтому в их
основе лежат структуры, предназначенные для решения этой задачи. По данным
структурам индексы подразделяются на
\begin{itemize}
    \item индексы на основе деревьев поиска,
    \item индексы на основе хеш-таблиц,
    \item индексы на основе битовых карт.
\end{itemize}

\section{Индексы на основе деревьев поиска}

Дерево поиска --- иерархическая структура, используемая для поска записей, в
которой каждый переход на более низкий уровень иерархии уменьшает интервал
поиска. При использовании деревьев поиска для построения
индексов необходимо учитывать, что требуется обеспечить как ускорение поиска
данных, так и уменьшение затрат на обновление индекса при вставках и
удалениях. По этим причинам при решении задачи поиска в базах данных
используют сбалансированные сильноветвящиеся деревья~\cite{arki}.

В данном случае сбалансированными деревьями назвают такие деревья, что длины
любых двух путей от корня до листьев одинаковы~\cite{encycl}. Сильноветвящимися
же являются деревья, каждый узел которых ссылается на большое число
потомков~\cite{squares}.  Эти условия обеспечивают минимальную высоту дерева для
быстрого поиска и свободное пространство в узла для внесения изменений в базу
данных без необходимости изменения индекса при каждой операции.

Наиболее используемыми деревьями поиска, имеющими описанные свойства, являются
B-деревья и их разновидность --- $B^+$-деревья~\cite{arki}.

\subsection{B-деревья}

Что такое B-деревья?

Как они выглядят?

Как они строятся?

Как изменяются при вставке?

Как изменяются при удалении?

Для чего подходят?

\subsection{\boldmath$B^+$-деревья}

Отличие от B-деревьев

Картинка

\subsection{Обученные индексы}

B-tree индексы можно рассматривать как модель сопоставления ключа позиции
искомой записи в отсортированном массиве~(рисунок~\ref{img:btree}).

\imgs{btree}{h!}{0.4}{B-деревья}

Такие индексы как бы предсказывают положение записи с минимаксной ошибкой
($min\_err = 0$, $max\_err = page\_size$). Поэтому можем заминить B-деревья на
линейную модель также с минимаксной ошибкой~(рисунок~\ref{img:learnedbtree}).

\imgs{learnedbtree}{h!}{0.4}{Обученный индекс}

Так для предсказания можно представлять Range Index Models как модели функции
распределения~(рисунок~\ref{img:cdf}):

\begin{equation}
    \text{position} = F(key) \cdot N,
\end{equation}

где $F(key)$ --- функция распределения, дающая оценку вероятности обнаружения
ключа, меньшего или равного ключу поиска, то есть $P(X < key)$;

~~~~$N$ --- количество ключей.

\imgs{cdf}{h!}{0.4}{Индекс как функция распределения}

Можно построить индексы на основе рекурсивной
модели~(рисунок~\ref{img:hiermodel}), в которой строится иерархия моделей из n
уровней. Каждая модель на вход получает ключ, на основе которого выбирает модель
на следующем уровне. Модели последнего этапа предсказывают положение записи.

\imgs{hiermodel}{h!}{0.4}{Рекурсивная модель индекса}

Можно использовать различные модели: например, на верхнем использовать нейронные
сети, а на нижних простые линейные регрессионные модели или даже простые
B-деревья.

\section{Индексы на основе хеш-таблиц}

\subsection{Хеш-индексы}


\subsection{Обученные хеш-индексы}

Хеш-индексы можно рассматривать как модель сопоставления ключа позиции
искомой записи в неупорядоченном массиве.

\imgs{hash}{h!}{0.5}{Хеш-индексы}

Функция распределения вероятностей распределения ключей  один из возможных
способов обучения хеш-индексов. Функция распределения масштабируется на размер
хеш-таблицы $M$ и для поиска положения записи аналогично случаю с B-деревьями
используется формула:

\begin{equation}
    h(K) = F(K) \cdot M,
\end{equation}

где $K$ --- ключ.

\section{Индексы на основе битовых карт}

\subsection{Фильтр Блума}


\subsection{Обученные индексы}

Данные индексы можно рассматривать как модель проверки существования записи в
массиве данных.

Фильтр Блума --- алгоритм используемый для проверки существования записи.

Фильтр Блума использует массив бит размером $m$ и $k$ хеш-функций, каждая из
которых сопоставляет ключ с одну из $m$ позиций. Для добавления элемента в
множество существующих значений ключ подается на вход каждой хеш-функции,
возвращающих позицию бита, который должен быть установлен в единицу. Для проверки
принадлежности ключа множеству, ключ также подается на вход $k$ хеш-функций.
Если какой-либо бит, соответствующий одной из возращенных позиций, равен нулю,
то ключ не входит во множество. Из этого следует, что данный алгоритм гарантирует
отсутсвие ложноотрицательных результатов.

\imgs{bloom}{h!}{0.3}{Bitmap-индексы}

%\textit{Может со 100\%-ной вероятностью сказать, что элемент отсутсвует в
%наборе, но то, что элемент присутсвует в наборе, со 100\%-ной вероятностью он
%сказать не может (возможны ложноположительные результаты)}

В случае индексов существования необходимо обучить функцию таким образом, чтобы
среди возвращенных значений для множества ключей были коллизии, аналогично для
множества неключей, но при этом не было коллизий возращенных значений для ключей
и неключей. 

В отличие от оригинального фильтра Блума, где $FNR = 0$, $FPR = const$, где
const выбрано априори, при обучении достигается заданное значение $FPR$ при $FNR
= 0$ на реальных запросах.
